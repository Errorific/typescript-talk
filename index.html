<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Typescript</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/solarized.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
        <section>
          <h1>Typescript</h1>
          <h2>JS for squares</h2>
          <p>Chris Mckay</p>
          <aside class="notes">
            <p>Example Note</p>
          </aside>
        </section>

        <section>
          <p>Typescript is...</p>
          <ul>
            <li class="fragment">Made by Microsoft in 2012, 1.0 in 2014</li>
            <li class="fragment">Strictly typed superset of JS</li>
            <li class="fragment">That thing Angular 2 is written in</li>
          </ul>
          <aside class="notes">
            <span>v2.0 last year</span>
            <span>find out when flow dates are</span>
          </aside>
        </section>
        <section data-background="/img/showmewhatyougot.gif">
        </section>
        <section>
          <table>
            <tbody>
              <tr>
                <td>Algebraic Data Types</td>
                <td>Got it</td>
              </tr>
              <tr>
                <td>Higher Kinded Types</td>
                <td>Don't got it</td>
              </tr>
              <tr>
                <td>Generics</td>
                <td>Got it</td>
              </tr>
              <tr>
                <td>Classes</td>
                <td>Got it</td>
              </tr>
              <tr>
                <td>Type classes</td>
                <td>Don't got it</td>
              </tr>

              <tr>
                <td>Pattern Matching</td>
                <td>Don't got it</td>
              </tr>
              <tr>
                <td>Currying</td>
                <td>Don't got it</td>
              </tr>
              <tr>
                <td>First class functions</td>
                <td>Got it</td>
              </tr>
              <tr>
                <td>Type inference</td>
                <td>Got it</td>
              </tr>
            </tbody>
          </table>
        </section>
        <section data-background="/img/disqualified.gif">
          <aside class="notes">
            <span>we're not getting all the cool functional stuff</span>
          </aside>
        </section>
        <section>
          Lets look at the language
        </section>
        <section>
          <pre><code class="typescript" data-trim>
var a = 'a';

let b = 'b';

const c = 'c';
          </code></pre>
          <aside class="notes">
            3 variable types. Var is a leaky variable. Let is lexically sealed. Const is lexically sealed
            and assignable once, not really immutable though.
          </aside>
        </section>
        <section>
          <pre><code class="typescript" data-trim>
const num: number = 3;

const bool: boolean = true;

const str: string = "a string";
          </code></pre>
          <aside class="notes">
            Basic primitives.
            One type of number, no refinement for floats etc
            2 strings, you want the lower case one
          </aside>
        </section>
        <section>
          <pre><code class="typescript" data-trim>
const nothing: undefined = undefined;
const nada: null = null;

const artistFormerlyKnownAs: symbol = Symbol('Prince');
          </code></pre>
          <aside class="notes">
            undef = uninitialised
            null = unavailable
            they're both basically the same except when they're not.
            Just don't use null

            Symbol, it makes completely unique values. es6, you probably won't need it, it's metaprogramming magic
          </aside>
        </section>
        <section>
          <pre><code class="typescript" data-trim>
const yolo: any = 42;

const slightlyLessYolo: object = new Date();
          </code></pre>
          <aside class="notes">
            any is anything
            object is anything not a primitive
          </aside>
        </section>
        <section>
          <pre><code class="typescript" data-trim>
const voldemort: never = `boom`;
          </code></pre>
          <aside class="notes">
            never is the bottom type. No equivilence. New with 2.0. Implemented to support control flow analysis.
          </aside>
        </section>
        <section>
          <pre><code class="typescript" data-trim>
function logHello (name: string): void {
  console.log('Hello ' + name);
}

function hello (name: string): string {
  return 'Hello ' + name;
}

const hello = (name: string): string => {
  return 'Hello ' + name;
}

// Infers string => string
const hello = name => 'Hello ' + name;
          </code></pre>
          <aside class="notes">
            Functions. Void is a type, means theres no return. You've got arrow functions, lambdas. Community is leaning towards lambda assigned to const because it means no one can override your prototype. Inference is pretty good here.
          </aside>
        </section>
        <section>
          <pre><code class="typescript" data-trim>
const stringArray: Array&lt;string&gt; = [ 'a', 'b', 'c' ];

const numberArray: number[] = [ 1, 2, 3 ];
          </code></pre>
          <aside class="notes">
            arrays. Community leans towards the square brackets trailing. Matches c# and doesn't confuse jsx
          </aside>
        </section>
        <section>
          <pre><code class="typescript" data-trim>
interface Point {
  x: number;
  y: number;
}

interface Point3D extends Point {
  z?: number;
}
          </code></pre>
          <aside class="notes">
            Interfaces are data types. Inheritence and multiple inheritence.
            ? is optional key. 
          </aside>
        </section>
        <section>
          <pre><code class="typescript" data-trim>
const p: Point = {
  x: 3,
  y: 2
};

const p3d: Point3D = p;
          </code></pre>
          <aside class="notes">
            Structural typing. The type names mean nothing. So long as the structure of the types are the same its equivelent. So long as the structure contains at least what is required then it can fulfil it.
          </aside>
        </section>
        <section>
          <pre><code class="typescript" data-trim>
class Queue {
  private data: string[] = [];

  constructor(seed: string[] = []) {
    this.data = seed;
  }

  push = (item: string) => this.data.push(item);
  pop = () => this.data.shift();
}

const queue = new Queue(['seed', 'values']);
          </code></pre>
          <aside class="notes">
            Classes are es6 classes. Compile down fine. Types here are realish and can be referred to at run time. Can extend interfaces.
          </aside>
        </section>
        <section>
          <pre><code class="typescript" data-trim>
class Queue&lt;T&gt; {
  private data: T[];

  constructor(seed: T[] = []) {
    this.data = seed;
  }

  push = (item: T) => this.data.push(item);
  pop = () => this.data.shift();
}

const queue = new Queue&lt;number&gt;([1, 2]);

// Inferred as Queue&lt;number&gt;
const inferredQueue = new Queue([1,2]);
          </code></pre>
          <aside class="notes">
            Generics. Type params to create dependence through your object. Can use them on interfaces too. Generic params can be said to extend other types to seal them. The generic can be inferred based on arguments if you set them up sanely.
          </aside>
        </section>
        <section>
          <pre><code class="typescript" data-trim>
interface Cat {
  smiling: boolean,
  teeth: number
}

interface Bus {
  speed: number,
  capacity: number
}

type CatOrBus = Cat | Bus;

type CatBus = Cat & Bus;
          </code></pre>
          <aside class="notes">
            
          </aside>
        </section>
        <section>
          <pre><code class="typescript" data-trim>
interface Dog {
  sound: 'Bark';
  walk(): void;
}

interface Cat {
  sound: 'Meow';
  pat(): void;
}

type Pet = Dog | Cat;
          </code></pre>
        </section>
        <section>
          <pre><code class="typescript" data-trim>
const whatsItDo = (p: Pet) => {
  // sound is available on both
  if (p.sound === 'Bark') {
    // p is a Dog in here
    p.walk();
  } else {
    // p is a Cat here
    p.pat();
  }
}
          </code></pre>
        </section>
        <section>
          <pre><code class="typescript" data-trim>
interface Bird {
  sound: 'Chirp';
  fly(): void;
}

type Pet = Dog | Cat | Bird;
          </code></pre>
        </section>
        <section>
          <pre><code class="typescript" data-trim>
const whatsItDo = (p: Pet) => {
  // sound is available on both
  if (p.sound === 'Bark') {
    // p is a Dog in here
    p.walk();
  } else {
    // error here, p = Cat | Bird
    p.pat();
  }
}
          </code></pre>
        </section>
        <section>
          <pre><code class="typescript" data-trim>
const whatIsIt = (p: Pet): string {
  // Error because unhandled case of Birb
  // Function lacks ending return statement and return type
  // does not include 'undefined'.
  switch (p.sound) {
    case 'Bark': return 'Dog';
    case 'Meow': return 'Cat';
  }
}
          </code></pre>
          <aside class="notes">
            Great for switches
            Not great, doesn't work properly for if-else. Side effect of how control flow analysis done, they're trying to fix it.
          </aside>
        </section>
        <section>
          <pre><code class="typescript" data-trim>
// byDefault.ts
const byDefault = "By Default";

export default byDefault;

// index.ts
import byDefault from './byDefault';
          </code></pre>
        </section>
        <section>
          <pre><code class="typescript" data-trim>
// explicit.ts
export const explicitExport = "Explicit";

// index.ts
import { explicitExport } from './explicit';
          </code></pre>
        </section>
        <section>
          <pre><code class="typescript" data-trim>
// explicit.ts
export const explicitExport = "Explicit";

// index.ts
import * as Explicit from './explicit';

console.log(Explicit.explicitExport);
          </code></pre>
        </section>
        <section>
          <pre><code class="typescript" data-trim>
declare function moment(...): moment.Moment;

declare namespace moment {
  type RelativeTimeKey = 's' | ... ;

  interface Moment extends Object{
    format(format?: string): string;
    ...
  }
}

export = moment;
          </code></pre>
          <aside class="notes">
            ambient declarations. Namespaces are modules. Can export top level stuff too.
            Can declare globally available variables, attach things to window, etc.
          </aside>
        </section>
        <section>
          screenshot of definitely typed
          <aside class="notes">
            definitely typed module count, dates?
          </aside>
        </section>
        <section>
          screenshot of npmjs @types namespace
          <aside class="notes">
            As of typescript 2.0. Types managed by npm rather than 'typings' tool. Exported from definitelytyped
          </aside>
        </section>
        <section>
          Image of file structure tree

          node_modules/@types/...
          node_modules/moment/moment.d.ts
          types/...
          <aside class="notes">
            Looks first for ambient declaration in your source, then in shipped npm package, then in @types packages
          </aside>
        </section>
        <section>
          tsc
          <aside class="notes">
            Theres a compiler, enough said
          </aside>
        </section>
        <section>
          JS Output
          <aside class="notes">
            outputs es6 or es5 or es3. Most language features compile to es3.
            Typescript already close enough to js that the outputted code is nearly the same with the types stripped.
            No chunky prelude etc to compile in, just the same esX polyfills you'd be using anyway.
          </aside>
        </section>
        <section>
          tslint
          <aside class="notes">
            lint is more interesting. All the traditional linting. Also type sensitive linting and compiled anti-patterns
          </aside>
        </section>
        <section>
          But Why?
          <aside class="notes">
            Nothing presented so far is that different from flow. Significantly worse than purescript or ghcjs or elm.
            So why use this one
          </aside>
        </section>
        <section>
          dumb looking js developer
          <aside class="notes">
            JS is a problem, but it's widely known. Retraining is expensive and hard to get buyin. Typescript almost is JS
          </aside>
        </section>
        <section>
          Typescript to control js
          <aside class="notes">
            Still like writing js, recongisable code. Type system strong enough to surpress class of errors. Suck the fun out of js.
          </aside>
        </section>
        <section>
          VS Code
          <aside class="notes">
            Awesome tools. vs code is Awesome. Fast, clean. Intellisense & documentation mapping. Great plugin support. Constant updates.
          </aside>
        </section>
        <section>
          <table>
            <tr>
              <td>vim</td>
              <td>Tsuquyomi</td>
            </tr>
            <tr>
              <td>emacs</td>
              <td>Tide</td>
            </tr>
          </table>
          <aside class="notes">
            Both do intellisense omnicompletion. Tide has been excellent for me.
          </aside>
        </section>
        <section>
          Angular 2
          rxjs
          <aside class="notes">
            Community adoption. Some big projects are driving it
          </aside>
        </section>
        <section>
          stackoverflow numbers for :-
          - typescript
          - flow
          - purescript
          - js
          - ghcjs
          <aside class="notes">
            Enough people using it to catch the problems before you do and fix it
          </aside>
        </section>
        <section>
          Definitely typed numbers
          <aside class="notes">
            No point gradual typing, and you don't want to do the work typing the world. You want it typed for you.
          </aside>
        </section>
        <section>
          Book titles?
          <aside class="notes">
            Educational resources being developed
          </aside>
        </section>
        <section>
          It's just enough
          <aside class="notes">
            More has been invested in typescript than any of its competitors. It aims a lot lower, but you know where you need to go if you want to stretch higher
          </aside>
        </section>
        <section>
          Questions?
        </section>
      </div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
        history: true,
        controls: true,
        slideNumber: true,
        center: true,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
